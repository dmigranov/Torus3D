bool Game::InitializeScene()
{
    //Настройка камеры
    {
        m_camera->SetPosition(0, 0, 0);
        m_camera->SetFovY(XM_PI / 2);
        m_camera->SetNearPlane(0.001f);
        m_camera->SetFarPlane(100.f);
        m_camera->Move(Vector3(0, 0, -XM_PI / 4));
    }

    auto earthTexture = new Texture();
    if (!earthTexture->Initialize(g_d3dDevice, L"earth.dds"))
        return false;
    textures.push_back(earthTexture);

    auto asteroidTexture = new Texture();
    if (!asteroidTexture->Initialize(g_d3dDevice, L"asteroid2.dds"))
        return false;
    textures.push_back(asteroidTexture);

    auto fabricTexture = new Texture();
    if (!fabricTexture->Initialize(g_d3dDevice, L"fabric.dds"))
        return false;
    textures.push_back(fabricTexture);

    {
        {
            float height = 0.5f;
            float s = sqrtf(1 - height * height);
            Mesh::VertexPosColor vertices[] = {
            { XMFLOAT4(s, 0.f, 0.f, height), XMFLOAT4(1.0f, 0.0f, 0.0f, 1.f), XMFLOAT2(0.f, 0.f) }, // 0
            { XMFLOAT4(0.f,  0.f, s, height), XMFLOAT4(1.0f, 0.0f, 0.0f, 1.f), XMFLOAT2(0.f, 1.f) }, // 1
            { XMFLOAT4(0.f,  0.f, -s, height), XMFLOAT4(1.0f, 0.0f, 0.0f, 1.f), XMFLOAT2(1.f, 0.f) }, // 2
            };

            WORD indices[] = {
                0, 1, 2, 2, 1, 0
            };

            Mesh* mesh = new SphericalMesh(_countof(vertices), vertices,
                _countof(indices), indices, SphericalRotationYW(XM_PI / 6));
            //meshes.push_back(mesh);

            mesh = new SphericalMesh(_countof(vertices), vertices,
                _countof(indices), indices, SphericalRotationXY(XM_PI) * SphericalRotationYW(XM_PI / 6));
            //meshes.push_back(mesh);
        }


        auto mesh1 = new SphericalSphere(0.15f, 20, 20, earthTexture);

        mesh1->AddUpdater(SphericalMesh::MeshUpdater([](Matrix in, float delta) {
            auto ks = Keyboard::Get().GetState();

            float gain = 0.045f;
            Matrix m = Matrix::Identity;
            if (ks.U)
                m = SphericalRotationYW(-gain); //так всегда вверх!
            if (ks.J)
                m = SphericalRotationYW(gain);
            if (ks.H)
                m = SphericalRotationXW(gain);
            if (ks.K)
                m = SphericalRotationXW(-gain);
            
            return in * m;
        }));

        meshes.push_back(mesh1);

        int sect = 9;
        for (int i = 1; i < sect; i++)
        {
            Mesh* mesh = new SphericalSphere(0.15f, 20, 20, earthTexture, SphericalRotationZW(i * XM_PI / sect));
            /*mesh->AddUpdater(SphericalMesh::MeshUpdater([i](Matrix in, float delta) {
                return SphericalRotationYZ(delta / i / 3.f) * SphericalRotationXY(delta / i / 2.f) * in * SphericalRotationYW(-delta / i / 6.f) * SphericalRotationZW(delta / 3.f) * SphericalRotationXW(delta / 12.f);
            }));*/
            meshes.push_back(mesh);
        }


        /*auto mesh2 = new SphericalSphere(0.2f, 20, 20, earthTexture, SphericalRotationXW(XM_PIDIV4));
        mesh2->AddUpdater(SphericalMesh::MeshUpdater([](Matrix in, float delta) {
            return SphericalRotationYZ(delta / 3.f) * SphericalRotationXY(delta / 2.f) * in * SphericalRotationYW(-delta / 6.f) * SphericalRotationZW(delta / 3.f) * SphericalRotationXW(delta / 12.f);
        }));
        meshes.push_back(mesh2);*/


        /*auto mesh3 = SphericalMeshLoader::LoadMesh("mesh2.sph");
        mesh3->SetTexture(fabricTexture);
        mesh3->SetWorldMatrix(SphericalRotationYZ(XM_PIDIV2) * SphericalRotationYW(0.05f));

        meshes.push_back(mesh3*/



    }

    return true;
}
