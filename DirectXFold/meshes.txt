Mesh::VertexPosColor vertices[] = {
            { GetCartesianFromSpherical(1.37f, 2.17f, 1.f), XMFLOAT3(0.0f, 0.0f, 0.0f) }, // 0
            { GetCartesianFromSpherical(1.f, 2.f, 3.14f), XMFLOAT3(0.0f, 1.0f, 0.0f) }, // 1
            { GetCartesianFromSpherical(1.97f, 2.57f, 1.f), XMFLOAT3(1.0f, 1.0f, 0.0f) }, // 2
        };



Mesh::VertexPosColor vertices[] = {
            { GetCartesianFromSpherical(0.f, XM_PIDIV2, XM_PI), XMFLOAT3(0.0f, 0.0f, 0.0f) }, // 0
            { GetCartesianFromSpherical(1.f, XM_PIDIV2, XM_PIDIV4), XMFLOAT3(0.0f, 1.0f, 0.0f) }, // 1
            { GetCartesianFromSpherical(2.5f, XM_PIDIV2, XM_PIDIV4), XMFLOAT3(1.0f, 1.0f, 0.0f) }, // 2
        };

ромбик:
float v1 = 0.9f, v2 = sqrtf(1.f - v1 * v1);
Mesh::VertexPosColor vertices[] = {
            { XMFLOAT4(v2, 0.f, 0.f, v1), XMFLOAT3(0.0f, 0.0f, 0.0f) },   // 0
            { XMFLOAT4(0.f,  v2, 0.f, v1), XMFLOAT3(0.0f, 1.0f, 0.0f) },  // 1
            { XMFLOAT4(0.f,  -v2, 0.f, v1), XMFLOAT3(1.0f, 1.0f, 0.0f) }, // 2
            { XMFLOAT4(-v2, 0.f, 0.f, v1), XMFLOAT3(1.0f, 0.0f, 0.0f) }   // 3
        };


//два треугольника икосаэдра?
Mesh::VertexPosColor vertices[] = {
        { XMFLOAT4(0.f, 0.f, 0.f, 1.f), XMFLOAT3(1.0f, 1.0f, 0.0f) }, // 0
        { XMFLOAT4(0.f,  1.f, 0.f, 0.f), XMFLOAT3(0.0f, 0.5f, 1.0f) }, // 1
        { XMFLOAT4(0.f,  0.f, 0.f, -1.f), XMFLOAT3(0.5f, 1.0f, 0.0f) }, // 2
        { XMFLOAT4(0.f,  -1.f, 0.f, 0.f), XMFLOAT3(0.0f, 1.0f, 0.5f) }, // 3
        };

        WORD indices[] = {
            0, 1, 2, 3, 0,
            0, 3, 2, 1, 0
        };

//какая-то линия
{
        //0.2 0.4 0.8
        Mesh::VertexPosColor vertices[] = {
        { XMFLOAT4(0.0f, 0.33166f, 0.5f, 0.8f), XMFLOAT3(1.0f, 1.0f, 0.0f) }, // 0
        { XMFLOAT4(0.0f,  0.f, 0.6, 0.8f), XMFLOAT3(0.0f, 0.5f, 1.0f) }, // 1
        { XMFLOAT4(0.0f,  0.f, -0.6f, 0.8f), XMFLOAT3(0.5f, 1.0f, 0.0f) }, // 2
        { XMFLOAT4(0.0f,  0.33166f, -0.5f, 0.8f), XMFLOAT3(0.0f, 1.0f, 0.5f) }, // 3
        };

        WORD indices[] = {
            0, 1, 2, 3, 0
        };

        Mesh * mesh = new Line(_countof(vertices), vertices,
            _countof(indices), indices);
        meshes.push_back(mesh);

    }






mesh1->AddUpdater(Mesh::MeshUpdater([](Matrix in, float delta) {
            std::srand(unsigned(std::time(0)));
            Matrix res = Matrix::Identity;
            int r = std::rand() % 6;
            switch (r)
            {
            case 0:
            case 1:
                res *= SphericalRotationXZ(delta);
                break;
            case 2:
            case 3:
                res *= SphericalRotationXZ(-delta);
                break;
            case 4:
                res *= SphericalRotationYZ(delta);
                break;
            case 5:
                res *= SphericalRotationYZ(-delta);
                break;
            }

            return res * in;
        }));




                /*float v1 = 0.99f, v3 = 0.08f, v2 = sqrtf(1.f - v1 * v1 - v3 * v3);
        Mesh::VertexPosColor vertices[] = {
            { XMFLOAT4(v2, 0.f, v3, v1), XMFLOAT4(1.f, 0.f, 1.f, 1.0f) },   // 0
            { XMFLOAT4(0.f,  v2, -v3, v1), XMFLOAT4(0.f, 1.f, 1.f, 1.0f) },  // 1
            { XMFLOAT4(0.f,  -v2, -v3, v1), XMFLOAT4(1.f, 1.f, 0.f, 1.0f) }, // 2
            { XMFLOAT4(-v2, 0.f, v3, v1), XMFLOAT4(0.f, 0.f, 1.f, 1.0f) }   // 3
        };

        WORD indices[] = {
            2, 1, 0,
            1, 2, 3,
            0, 1, 3,
            3, 2, 0
        };*/

        /*Mesh::VertexPosColor vertices[] = {
            { XMFLOAT4(0.6f, 0.0f, 0.0f, 0.8f), XMFLOAT4(0.0f, 0.0f, 0.0f, 1.f) },   // 0
            { XMFLOAT4(0.0f,  0.6f, 0.0f, 0.8f), XMFLOAT4(0.0f, 1.0f, 0.0f, 1.f) },  // 1
            { XMFLOAT4(0.0f,  -0.6f, 0.0f, 0.8f), XMFLOAT4(1.0f, 1.0f, 0.0f, 1.f) }, // 2
        };

        WORD indices[] = {
            0, 1, 2, 2, 1, 0
        };*/


/*Mesh::VertexPosColor vertices[] = {
            { XMFLOAT4(0.6f, 0.0f, 0.0f, 0.8f), XMFLOAT3(0.0f, 0.0f, 0.0f) },   // 0
            { XMFLOAT4(0.0f,  0.6f, 0.0f, 0.8f), XMFLOAT3(0.0f, 1.0f, 0.0f) },  // 1
            { XMFLOAT4(0.0f,  -0.6f, 0.0f, 0.8f), XMFLOAT3(1.0f, 1.0f, 0.0f) }, // 2
            { XMFLOAT4(-(sqrtf(0.11f)), 0.f, -0.5f, 0.8f), XMFLOAT3(1.0f, 0.0f, 0.0f) }   // 3
        };*/




    /*{
        Mesh::VertexPosColor vertices[] = {
            { XMFLOAT4(0.6f, 0.0f, 0.0f, 0.8f), XMFLOAT3(1.0f, 0.0f, 0.0f) },   // 0
            { XMFLOAT4(0.0f,  0.6f, 0.0f, 0.8f), XMFLOAT3(0.0f, 0.5f, 0.0f) },  // 1
            { XMFLOAT4(0.0f,  -0.6f, 0.0f, 0.8f), XMFLOAT3(.5f, 0.0f, 0.5f) }, // 2
            { XMFLOAT4(-0.33166f, 0.f, -0.5f, 0.8f), XMFLOAT3(0.0f, 1.0f, 1.0f) }   // 3
        };

        WORD indices[] = {
            2, 1, 0,
            1, 2, 3,
            0, 1, 3,
            3, 2, 0
        };

        Mesh *mesh = new Mesh(_countof(vertices), vertices,
            _countof(indices), indices, SphericalRotationXW(XM_PI/2));
        meshes.push_back(mesh);
    }*/




            /*Mesh::VertexPosColor vertices[] = {
        { XMFLOAT4(-0.6f, 0.0f, 0.0f, 0.8f), XMFLOAT4(1.0f, 0.0f, 0.0f, 1.f) }, // 0
        { XMFLOAT4(0.0f,  0.6f, 0.0f, 0.8f), XMFLOAT4(0.0f, 0.0f, 1.0f, 1.f) }, // 1
        { XMFLOAT4(0.0f,  -0.6f, 0.0f, 0.8f), XMFLOAT4(0.0f, 1.0f, 0.0f, 1.f) }, // 2
        };*/




                Mesh* test = SphericalMeshLoader::LoadMesh("mesh1.sph");

        float v1 = 0.99f, v3 = 0.08f, v2 = sqrtf(1.f - v1 * v1 - v3 * v3);
        Mesh::VertexPosColor vertices[] = {
            { XMFLOAT4(v2, 0.f, v3, v1), XMFLOAT4(1.f, 0.f, 1.f, 1.0f) },   // 0
            { XMFLOAT4(0.f,  v2, -v3, v1), XMFLOAT4(0.f, 1.f, 1.f, 1.0f) },  // 1
            { XMFLOAT4(0.f,  -v2, -v3, v1), XMFLOAT4(1.f, 1.f, 0.f, 1.0f) }, // 2
            { XMFLOAT4(-v2, 0.f, v3, v1), XMFLOAT4(0.f, 0.f, 1.f, 1.0f) }   // 3
        };

        WORD indices[] = {
            2, 1, 0,
            1, 2, 3,
            0, 1, 3,
            3, 2, 0
        };
